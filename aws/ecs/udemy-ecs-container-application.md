# ECSの学習

## 学習内容
### 技術
- コンテナアプリの背景と起訴
- マイクロサービスアーキテクチャ
- CICDパイプライン
- 状態管理
- デプロイ手法
- オートスケーリング
- ネットワーク

### フェーズ
- 基礎
- 設計・開発
- リリース
- 運用

## コンテナアプリケーション開発の基本
### コンテナとは??
- アプリケーションとそれに必要な周辺ソフトウェアをパッケージ化したもの
ホストマシンから隔離されているため影響を受けない。
持ち運び可能。
- 開発環境の統一
- スケーラビリティ: コンテナを増やすことで簡単にアプリをスケールできる
- CI/CDとの相性: テスト -> そのまま本番環境にデプロイできる

### スケーリング
システムの利用者の増大に応じて、システム規模を拡大縮小すること。スケーラビリティ = スケールのしやすさ
コンテナは即立ち上げ可能なため、ユーザーが増えたらスケールさせることが容易。
一つのホストマシンだと、CPUやメモリが足りなくなるが、AWSなどクラウドインフラだとクリック一つで増やせるためコンテナと相性がいい。

### コンテナオーケストレーション
ユーザーの増減に応じてコンテナを増やしたり減らしたりをする必要がある。1台のサーバではできないため複数サーバを用意する必要がある。
どのサーバに配置するかを解決してくれるのがコンテナオーケストレータ。
CPUメモリリソース・負荷状況を監視 -> どのサーバに配置するのが最適か・効率的か判断、不要なコンテナを破棄。

### ECSの基本構造
![learn-ecs drawio](https://github.com/user-attachments/assets/f1efd6ac-a48f-4fcb-afd7-9dc29f2a8941)

TaskはServiceの中でなく単体でも可能
Taskが最小単位としてコンテナデプロイを行っている。
Task = 1つ以上持たせることが可能。
#### Task定義: Taskそのものの設計図で、Taskを作成し、ECSに与えることで作りたいコンテナを作成。(Json)
コンテナ設定・リソース設定・環境変数・ログ設定などコンテナに必要なものを定義

#### Service
Taskの状態・個数を理想状態に維持する
- Taskの維持管理
- スケーリング
- 負荷分散
- アップデートとデプロイ

### ECSの作成手順
Cluster -> Service -> Task

### ECSの実行環境
1. EC2ベースの実行環境
   - 高い柔軟性
   - コスト最適
   - OS等管理コストがかかる
2. Fargateの実行環境
   - サーバレスでOS等管理が不要
   - シンプルで簡単に始めやすい
   - 柔軟性が低い

### ECR
コンテナイメージを格納、管理、デプロイするためのAWSサービス。
コンテナイメージの保存・管理を可能にする = コンテナイメージレジストリの一種。

## AWSのネットワーク
### VPC・Subnet
- VPC: AWS上に自由に作成できる専用の仮想ネットワーク環境。
- Subnet: VPC上のIPアドレス範囲を区切ったネットワーク空間。複数作成可能。
- 手順: VPC -> Subnet の順に作成

### プライベートIPアドレス
- グローバルIPアドレス: インターネット上で一意的なアドレス
- プライベートIPアドレス: 特定のネットワーク内でのみ使用されるアドレス

#### プライベートIPアドレスの範囲
RFCの規格で決まっている  
[RFC](https://datatracker.ietf.org/doc/html/rfc1918)
10.0.0.0 - 10.255.255.255
172.16.0.0 - 172.31.255.255
192.168.0.0 - 192.168.255.255

### CIDR
プライベート内で無秩序にIPアドレスを使用すると、通信はできるが管理が難しくなる。将来増やしたい場合などに重複が発生する可能性がある。
IPアドレスの衝突を考慮して、利用するプライベートIPアドレスの範囲を決める必要がある。-> CIDRで定義

10.0.0 -> network部
.1 -> host部

#### ネットワーク部
どのネットワークかを特定するもの。

#### ホスト部
ネットワーク内の機器を特定するもの。

IPアドレスは 0 - 255 の数字を組み合わせたもの
2進数で表現
ネットワーク部の範囲とホスト部の範囲はケースバイケース

- ネットワーク部の範囲が広い場合: 多くのネットワークグループが作れるが、少しの機器しかネットワークに紐づけられない。
- ホスト部の範囲が広い: 少しのネットワークグループしか作られないが、多くの機器がネットワークに紐づけられる。

#### CIDRとは?
ネットワークのアドレスとネットワーク部の範囲を表す記法。利用できるIPアドレスの範囲が分かる。

- ネットワーク部が28bitある場合: このネットワークでは 10.0.0.0 ~ 10.0.0.15 の範囲でIPアドレスが利用できる。
10.0.0.0/28 = 00001010.00000000.00000000.0000(0001)
IPアドレスは全部で32個あるのだが、上記の例では28個までがネットワーク部ということ。
残りの4個はホスト部で、それぞれのIPアドレスを区別するために使用する。
4ビットの組み合わせ: 0000, 0001, 0010, ... , 1111 （合計16種類）
つまり、CIDR「/28」ではネットワークの一部を固定して、残りの部分でこのネットワーク内のアドレスを割り当てる仕組み。

- 例 VPC: 10.0.0.0/16 = 10.0.0.0 ~ 10.0.255.255
- 例 Subnet1: 10.0.0.0/24 = 10.0.0.0 ~ 10.0.0.255
- 例 Subnet2: 10.0.1.0/24 = 10.0.1.0 ~ 10.0.1.255

### VPCとSubnetの作成
- リージョン: オレゴン
- VPC: my-workspace-vpc, 10.0.0.0/20
- Subnet(private): my-workspace-subnet-app-private1-a, AZ: us-west-2a, 10.0.0.0/24
- Subnet(public): my-workspace-subnet-app-public1-a, AZ: us-west-2a, 10.0.1.0/24

### リージョンとアベイラビリティゾーン
#### リージョンとは
- 実ユーザの想定地域と近いほうが応答時間が早くなる
- リージョンによって同じサービスでも費用が異なる
- 一部サービスが使えないリージョンもある
#### アベイラビリティゾーン
- VPC: アベイラビリティゾーン✕
- Subnet: アベイラビリティゾーン〇
サブネット単位で複数のAZを設定できるので、リスクが分散できる。
 
### パブリックサブネットとプライベートサブネット
#### パブリックサブネット
インターネットに直接アクセスできるサブネット
サーバはグローバルIPアドレスを持つことで外部からアクセスできる

#### プライベートサブネット
インターネットに直接アクセスできないサブネット

### ルートテーブルとインターネットゲートウェイ
#### ルートテーブル
| 送信先 | ターゲット |
|-------| ---------- |
| 宛先  | どこに転送するのか |
| 10.0.0.0/24 | local | -> Subnet内に通信する

詳細度から順にルーティングが決まる
ターゲットには、IGW, NGWなど
パブリックサブネットにはInternet Gatewayが含まれる。

#### ルートテーブル・インターネットゲートウェイの作成
- ルートテーブル
my-workspace-rtb-private1-a, my-workspace-vpc
my-workspace-rtb-public1-a, my-workspace-vpc

- インターネットゲートウェイ
my-workspace-igw

#### 作成後に行うこと
- IGWにVPCをアタッチ
- ルートテーブルにIGWを設定
- Subnetにルートテーブルの関連付けを行う
  - private Subnet -> 
private のルートテーブルに
  - public Subnet -> public のルートテーブルに

![learn-ecs-ルートテーブル drawio](https://github.com/user-attachments/assets/ec87c42c-c8c9-46b4-80ed-9b3e27007e58)

### セキュリティグループ
VPC内のサーバなどに紐づけて通信を制御するための仮想ファイアウォール。
アウトバウンドとインバウンドのルールを定義してアクセスを管理。
アウトバウンドの応答通信は、インバウンドルールは適用せず常に許可。

- ホワイトリスト方式: インバウンド、アウトバウンドルールに記載のないものはすべて不許可。
- 高い柔軟性: 特定のセキュリティが設定されているものは許可。
- 即時反映: ルール変更はすべての関連するインスタンスに即時反映。

## ECSでシンプルなアプリ作成(練習用)
### システム設計図
![learn-ecs-Nginxコンテナ drawio](https://github.com/user-attachments/assets/aa527cb3-eec0-4829-96cb-8931566af3e2)
![learn-ecs-簡単なアプリ drawio](https://github.com/user-attachments/assets/0a0aa9ca-f17e-43c4-8a27-cd571bb08e19)
### 要件
**GOAL**: Nginxを画面に表示させる
- タスク -> Cluster直下に配置
- Fargateを使用
- Task定義
- Nginx -> ECRからpull (通常はDockerfileを通じてECRにpush -> それをpullして起動させる)

### ハンズオン流れ

#### リージョン:
オレゴン

#### ECSの作成:
**クラスターの作成**
- my-app-cluster
- AWS fargate

#### タスク定義
**新しいタスク定義の作成**
- my-app-frontend
- AWS Fargate
- Linux/x86_64
- CPU: .25 vCPU
- GB: .5GB
- タスクロール: 権限付与する場合
- タスク実行ロール: 新しいロールの作成
- コンテナ-1 の作成(複数可能) -> イメージURI: Amazon ECR Public GalleryからNginxを取得
  名前: frontend, 必須コンテナ -> Yes
- ログ収集: Yes

#### クラスターの作成
**タスクのデプロイ**
- クラスター -> タスク -> 新しいタスクの実行
- コンピューティングオプション: 起動タイプ
- アプリケーションタイプ: タスク
- ファミリー: my-app-frontend
- 必要なタスク: 1
- タスクグループ: なし
- VPC, Subnet
- セキュリティグループの作成



## Blue/Greenデプロイ
### コンテナを利用したアプリケーション開発におけるデプロイ(アップデート時に起こりやすい問題)
App v1, App v1, App v1 -> App v2, App v2, App v2
古いコンテナをいったん閉じて新しいバージョンのコンテナを開く必要があるのだが、どういう手順でアップデートする??

#### 古いコンテナを一括で止める -> 新しいコンテナを立ち上げる
問題1: 古いコンテナを止めてから新しいコンテナを起動するまでアプリを止めてしまうことになる。
問題2: 深刻な bag が発生する可能性がある。

#### 上記の課題を解決するためのECSがサポートするデプロイ方式
- ローリングアップデート: コンテナひとつづつ新しいコンテナに置き換える方法(コンテナが0にならないのでユーザーはどこかのコンテナにアクセスすることができる)
- Blue/Greenデプロイ: 新旧のバージョンを並行稼働させることでダウンタイムを最小限に抑え、リスクを管理しやすくする手法。(**AWS CodeDeploy**を使って実装)

### Blue/Greenデプロイの流れ

![Greenデプロイ drawio](https://github.com/user-attachments/assets/5bbd85c0-5a23-465e-b18c-51af4a6aff69)
1. 古いほうのコンテナにルーティングしたまま、いきなりアプリを含んだコンテナを一気に立ち上げる。
2. Load Balancerを新しいほうのコンテナに向ける
3. 古いコンテナを削除(コスト節約のため、不要になった時点で削除)

### Load Balancerの中身
- Linsener: 特定のプロトコルを監視する(例: HTTP:80 -> Target Group Blue に流し込む設定)
- Target Group: Listenerのルールに基づいて通信を受け取る対象をグルーピング化したもの

#### Greenアプリが正常稼働しているか確認する方法
1. ターゲットグループのヘルスチェックを行う
2. 開発者が手動で事前にHTTP:9000を使った動作確認

![Greenデプロイ drawio](https://github.com/user-attachments/assets/4cd92776-20d9-426d-b585-ad4bde75fcc2)

### ハンズオン流れ

#### リージョン:
オレゴン

#### セキュリティグループの作成
- EC2 -> セキュリティグループ
- インバウンドルール: HTTP -> anywhere, カスタムTCP -> 自分のIP/32

#### ロードバランサの設定
- Type: Application Load Balancerを選択(HTTP, HTTPS のレイヤーでのルーティングのためにこれを選択)
- 名前: my-app-alb
- スキーム: インターネット向け
- ロードバランサーの IP アドレスタイプ: IPv4
- ネットワークマッピング: 作成したVPC、アベイラビリティゾーン(2つ以上必要なので足りない場合はこの時に別アベイラビリティゾーンを設定したサブネットを追加)(ルートテーブルは後で作成)
- セキュリティグループの設定: my-app-lb-sg
- リスナーとルーティング -> ターゲットグループの作成: IPアドレス, グループ名`my-app-frontend-tg-1`, ターゲットグループはそのまま(defaultのIPアドレスは削除)

一般ユーザーからHTTP:80 -> Target Groupに先導まで作成済み。

#### ECS Service作成
ECS -> クラスターを選択 -> Serviceを作成
- コンピューティングオプション: 起動タイプ, FARGATE, LATEST
- デプロイ設定: アプリケーションタイプ -> サービス, ファミリー -> my-app-frontend, リビジョン -> 最新, サービスタイプ -> レプリカ, 必要なタスク -> 1, デプロイオプション -> Blue/Greenデプロイ, デプロイ設定 -> CodeDeployDefault.ECSAllAtOnce,
CodeDeploy のサービスロール -> IAMの作成(AWSCodeDeployRoleForECS -> 名前: AWSCodeDeployRoleForECS), 

![スクリーンショット 2024-09-11 112656](https://github.com/user-attachments/assets/4bf97f2d-ac51-4da2-93cd-568e2b7c091b)

![スクリーンショット 2024-09-11 123334](https://github.com/user-attachments/assets/6505a6ad-8e31-43bc-82f4-cecf42c05646)


![スクリーンショット 2024-09-11 112656](https://github.com/user-attachments/assets/b4f0fc42-2101-447e-95bb-c68037afb470)

作成後、ロードバランサーのリスナーとルールに9000番で設定したルールが追加されている

![スクリーンショット 2024-09-11 124253](https://github.com/user-attachments/assets/2b10f031-e20e-4fc5-aa34-12ccf5f1183b)


### Code Deployの設定
Blue/Greenデプロイがまだ未完成なので、デプロイメントは作成されていない。
CodeDeploy -> アプリケーション -> 作成されたDeployを選択

![スクリーンショット 2024-09-11 135032](https://github.com/user-attachments/assets/0061800f-03cc-418d-840a-a85f94b5b8f0)

#### デプロイ設定
- リスナーが新しいターゲットグループに変更するのを手動か自動化設定
トラフィックの再ルーティング: トラフィックを再ルーティングするタイミングを指定します -> 2時間

- Blueコンテナを削除するまでの猶予時間
元のリビジョンの終了: 1時間

### ECR設定
1. 自分たちのECRリポジトリを作成
   ECR -> リポジトリ -> プライベートリポジトリ作成
2. "Hello World"と表示する簡単なアプリを作成する
**開発の流れ**
![learn-ecs-original-application drawio](https://github.com/user-attachments/assets/b68e0e4d-d6df-40b0-9add-c773e1700ea6)
- LocalでDockerfileを作成し、テスト
- IAM でアクセス権限を付与
- AWS CLIをインストールし、アクセスキー等の設定を行う

4. 作成したアプリを含むコンテナイメージをECRリポジトリにアップロード(Push)する
- ECRのプッシュコマンドを表示通りにコマンドを入力しPush -> ECRにPushしたイメージが反映されているか確認
- Blue/GreenのGreenで使用するためのタスクを追加 (URIはPushしたイメージのURI)
- クラスター -> 作成したクラスター -> サービスの更新 -> 最新のリビジョンを選択 -> 

ECSの削除はCloudFormationから行うと楽。


