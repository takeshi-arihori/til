# Good Code, Bad Code ～持続可能な開発のためのソフトウェアエンジニア的思考～　MEMO

Kindle

参考になった個所や、後程深堀していきたい内容などをメモ

## 2.1 疑似コードでのnullの扱い方
null安全: 変数や関数の返す値が`null`である可能性を示し、最初にその値を`null`か否かをチェックしなければ、利用できないようにコンパイラーが強制するというもの。
**TypeScript**
tsconfig.jsonで以下を設定
```typescript
{
  "compilerOptions": {
    // ...他の設定
    "strict": true
  }
}
```

**他の厳格なチェックは入れたくないがNull安全性だけは確保したい場合**
```typescript
{
  "compilerOptions": {
    // ...他の設定
    "strictNullChecks": true
  }
}
```


## 2.2 なぜ抽象化レイヤーを作るのか
大きな問題と小さな問題の解決策は、一連のレイヤーを形成すること。
問題を再帰的に小さな問題に分解し、抽象化レイヤーを作る努力をすれば、ここのコードがそれほど複雑に見えることはない。部分部分ではいくつかの簡単に理解できる概念だけを取り扱うため。
たとえ問題が非常に複雑でも、小さな問題に切り出して正しい抽象化レイヤーを作れば、その複雑さを制御できる。

### 2.2.1 抽象化レイヤーとコード品質の柱
- 読みやすさ
  コードベースのコードを1行1行すべて理解できないが、一度にいくつかの大まかな抽象概念を理解して利用することはとても簡単にできる
  きれいで明確な抽象化レイヤーを作れば、一度に1つや2つのレイヤーと少しの概念のみを扱うだけでよいことになる。
- モジュール性
  抽象化レイヤーが小さな問題への解決策をきれいに分割し、その小さな問題同士の実装がお互いに干渉していなければ、他のレイヤーやコードに影響を与えることなく、実装を交換できる。
- 再利用性と汎用化
  小さな問題への解決策がきれいな抽象化レイヤーとして与えられているなら、その小さな問題の解決策として再利用できる。その問題が適切に小さな問題に分割されているなら、その解決策は汎用化されて多くの様々なシナリオに役立つ可能性がある。
- テスタビリティ
  それぞれの小さな問題への解決策が健全に動いていることを担保する必要がある。

#### クラスをどのように分割すべきか適切に判断するための視点
- コードが思ったほど読みやすくない場合
- コードがそれほどモジュール化されていない場合
- コードの再利用性が低い場合
- コードが汎用化されていない
- 適切にテストしにくい

**コードを改善するために DI を使用**

## 2.3 コードのレイヤー
抽象化レイヤーと作ることとは、コードを異なる単位に分割すること。
その単位は他の単位に依存して**依存関係グラフ**を作る。

例
- 関数
- クラス(構造体やmixinなど潜在的にクラスのようなものも含む)
- インターフェイス(同等の構成概念含む)
- パッケージ、名前空間、モジュール

### 2.3.2 関数
できるだけ細かく分割することに意義がある。
理想的には、短く1行にうまくまとめられた文のように読めるべき。

- 単一のタスクを行う
- 他の適切な名前を付けた関数を呼びだし、より複雑な振る舞いを構成する

#### point
- 作成した関数は、まずその関数を1つの文として試しに読んでみる
- その文が読みづらかったり、非常に不格好だったりするなら、おそらく関数が長すぎるため、もっと小さい関数に分割することが有効

### 2.3.3 クラス
以下のような理論や経験則が提唱されている
- 行数: 300行を超えるクラスは多くの概念を含みすぎており、分割すべきなのは事実である。
- 凝集: クラス内のものがどれだけ適切なクラスに「所属」しているかを評価するもので、凝集度の高いクラスがよいとされている。
  - 逐次的凝集: 1つの出力が他の入力に必要な場合に発生。例: コーヒー豆を挽かなければコーヒーの抽出はできない。(コーヒー豆を挽くというプロセスの出力が、コーヒーの抽出の入力となっている)
  - 機能的凝集: 一連のものがすべて1つのタスクのために働く場合に発生。例: ケーキつくりの道具をすべてキッチン専用の引き出しに収納すること(それぞれケーキを作るという同じ機能のために働くので、これらは凝集していると判断できる)
- 関心の分離: 「システムが個別に対処している問題(関心)ごとに、独立したコンポーネントとして分離すべき」と推奨する設計原則

### 2.3.4 インターフェイス
- **インターフェイスの定義**: レイヤー間の境界を強制的に明確にしたり、実装の詳細がそれぞれのレイヤー間で漏れ出していないことを担保するために利用するアプローチ
既存の抽象化レイヤーに対して2つ以上の実装が存在したり、これからも別の実装が増えていくと考えられる場合、インターフェイスを定義するのがよい。
それによってコードのモジュール化がしやすくなり、再構築も容易になる。

レイヤーからどのパブリック関数を公開するかを決定する。
レイヤーの具体的なコードを含むクラスは、このインターフェイスを実装する。
このクラスのレイヤーよりも上位レイヤーのコードは、このインターフェイスのみに依存し、具体的なクラスの実装には一切依存しないはず。

#### インターフェイスは、全てに対して定義するべきか？
**メリット**
- パブリックAPIを明確にする
- 1つの実装しか必要ないという予測が間違っている可能性がある
- テストしやすくなる
- 同じクラスで2つの小さな問題を解決できる

**デメリット**
- 少々手間がかかる
- コードをより複雑にする

多くのメリットが得られる場合のみにインターフェイスを利用し、インターフェイスを利用すること自体を目的にしないこと。

## 3-2 どうやってあなたのコードの使い方を理解するのか
**作成したコードに依存している箇所を変更するときに必要な情報**
- どのシナリオで呼び出すか
- 何を表していて、いつ使われるべきか
- どんな値を使って呼ぶか
- コードはどういった動作をするか
- どんな値を返す可能性があるか

**確認方法**
- 名前に注目(関数、クラス、列挙型など) ※実践的
- データの型に注目(関数とコンストラクターのパラメーターや戻り値の型) ※実践的
- ドキュメントや関数やクラス単位のコメントを読む ※実践的
- 直接、あるいはチャットやメールを通して尋ねる
- コードを読む(関数の基本的な実装の詳細やクラス)

