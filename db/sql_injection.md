# SQLインジェクションとは

SQLインジェクションとは、悪意のあるユーザーが不正なクエリ( データベースへの命令文 )を書き、データベースへアクセスしてデータの漏洩・改ざんを行う攻撃です。

---

## SQLインジェクションで受ける可能性がある被害
1. **データの漏洩**  
   データベース内のすべての情報が外部に盗まれる。

2. **データの改ざん**  
   データベースの内容が書き換えられる。

3. **認証回避**  
   IDやパスワードを用いずに不正ログインされる。

4. **その他の攻撃**  
   データベースサーバー上のファイルの読み書きや、プログラムの実行が行われる。

---

## SQLインジェクション攻撃の例

### 1. エラーメッセージ経由の情報漏洩
不正なSQL文を入力し、アプリケーションが返すエラーメッセージからデータベース構造を推測する手法です。  
多くのアプリケーションは、SQL文のエラーが発生した場合、エラーメッセージを画面に表示してしまうことがあります。エラーメッセージにはテーブル名やカラム名が含まれる場合があり、攻撃者はこれらの情報を手掛かりにさらに高度な攻撃を組み立てます。  
**対策:**  
- 本番環境では詳細なエラーメッセージをユーザーに表示しない。  
- 開発・検証環境でのみ詳細を出すように設定し、ログにのみ詳細情報を残す。

### 2. UNION SELECTを用いた情報漏洩
`UNION` 句を利用して、攻撃者が意図したデータを任意の `SELECT` 文と結合して取得する手法です。  
例えば、本来は「`SELECT * FROM products WHERE id=1`」のみを許容している場合でも、攻撃者が「`UNION SELECT credit_card_info FROM users`」のようなSQLを注入すると、本来アクセスできないテーブル（`users` テーブルなど）から情報を引き出すことが可能になります。  
**対策:**  
- テーブル名やカラム名をユーザー入力として受け取らない。  
- 絶対に文字列連結でSQL文を生成せず、プレースホルダを利用する。

### 3. SQLインジェクションによる認証回避
ログイン画面などで「`' OR '1'='1`」のような文字列を入力し、認証をすり抜ける代表的な手口です。  
例えば `WHERE username = '$username' AND password = '$password'` のように文字列連結しているとき、攻撃者が `username` に「`' OR '1'='1`」を入れれば `WHERE username='' OR '1'='1' AND password = ''` のように書き換わり、論理式が常に真となってしまいます。  
**対策:**  
- 入力値は必ずサニタイズし、プレースホルダ（バインド変数）で処理する。  
- 認証機構を独自実装する場合は特に注意し、使用するフレームワークの認証機能を利用すると安全性が高まる。

### 4. SQLインジェクションによるデータ改ざん
悪意のあるSQL文を注入することで、データベース上のレコードを削除・変更したり、不正レコードを挿入したりする攻撃です。  
例えば「`1; DELETE FROM users;`」のようにセミコロンを挟んで複数のSQL文を連結し、正規のクエリと一緒にデータ削除クエリを実行させる手法が知られています。  
**対策:**  
- セミコロンで文を区切るなどの攻撃を防ぐために、常にプレースホルダを使用する。  
- データベース接続ユーザーに、必要最小限の権限を付与（権限分割）しておくことで、万一の被害を最小限に抑える。

---

## 脆弱性が生まれる原因

SQLインジェクションの主な原因は、**SQL文内でリテラル（定数）を不適切に扱う**ことにあります。特に、ユーザーが入力した値を**そのまま文字列連結してSQL文に組み込む**ことで、攻撃に利用される可能性が高くなります。

---

### 文字列リテラルの扱い
SQLでは文字列リテラルをシングルクォート (`'`) で囲みます。  
そのため、文字列リテラル内にシングルクォートを含む場合は、**シングルクォートを2つ重ねる**などのエスケープ処理が必要です。

#### 攻撃例(認証):
**SQL文**
```sql
$sql = "SELECT * FROM users WHERE id = '$id' AND PWD = '$pwd'";
```
ユーザー名とパスワードを入力すると、ログインできるようなFORMがあるとします。  
- ユーザー名: `yamada`
- パスワード: `password`

もし攻撃者がパスワードを知らない状況で、以下のような入力を行った場合:
```sql
- ユーザー名: yamada
- パスワード:' OR '1'='1
```
この場合もログインに成功します。  
実際には、SQL文は次のように変更され、すべてのデータが取得されてしまいます。
```sql
SELECT * FROM users WHERE id = 'yamada' and pwd = '' OR '1' = '1'
```
このため、WHERE句が常に成立する状態となる

---

## 対策

SQLインジェクションを防ぐためには、以下の対策を講じる必要があります。

### 1. プレースホルダの使用
SQL文を組み立てる際に、ユーザー入力を直接埋め込まず、プレースホルダ（バインド変数）を利用します。これにより、SQL文とデータが分離され、インジェクションを防止できます。

参考: [安全なSQLの呼び出し方](https://www.ipa.go.jp/security/vuln/websecurity/ug65p900000196e2-att/000017320.pdf)
PHP（PDO）バージョンの例  
```sql
$stmt = $pdo->prepare("SELECT * FROM users WHERE name = ?");
// パラメータをバインド（1番目の? に「山田」という文字列を割り当てる）
$stmt->bindValue(1, "山田", PDO::PARAM_STR);
```

`name=?` のようにプレースホルダに値を割り当てることをバインドという

## Laravelでの対策

LaravelクエリビルダはアプリケーションをPDOパラメーターによるバインディングを使用している。そのためバインドする文字列をクリーンにしてから渡す必要はないです。  
エスケープなしのSQLを使用する場合はDB::rawを使用するため、SQLインジェクションの脆弱性を生まないように気を付ける必要があります。

### DB:rawでの脆弱なSQL
```
public function store(Request $request)
{
    $id = '5; delete from posts'; // 悪意のあるユーザによって送られてきたid
    $posts = DB::table('posts')->whereRaw("id = ${id}")->get();

}
```

